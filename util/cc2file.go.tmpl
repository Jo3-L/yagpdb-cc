{{/*
	This command sends your CC(s) code in a text file, rather than "plain" Discord messages, preserving Tabs, markdown, etc. 
	You can especify more than one ID or trigger, and bot will generate one file per input parameter. If none are provided, output will be CC list

	Trigger type: Command
	Recommended trigger 1: "cc2file"
	Recommended trigger 2: "cc" IF you disable built-in "cc" command, via CommandOverrides
	
	Usage: `-cc2file <ID or Trigger> [ID or Trigger] [ID or Trigger]...`. For example: `-cc2file 10 "te st" 23`
*/}}

{{/* CONFIGURATION AREA STARTS */}}
	{{/*If `true`, bot will do that. Prevents flood in the chat*/}}
	{{$limitTo5CCs:= true}}

	{{/*If `true`, the info of each CC will be included in the message content*/}}
	{{$CCInfo_MessageContent:= true}}

	{{/*If `true`, the info of each CC will be included in the attached file*/}}
	{{$CCInfo_Attachment:= true}}

	{{/*These CCs will NOT be processed. DON'T QUOTE THE NUMBERS NOR ADD "#" TO THEM*/}}
	{{$blacklisted_CCIDs:= cslice 1234 5678}}
{{/* CONFIGURATION AREA ENDS */}}



{{/*
	sendLongMessage is able to split a long text and send them in individual messages (of 2000 chars long max)

	INPUT (arguments) is an SDICT with keys:
		"channelID" = Channel ID/Name/nil where message(s) will be sent
		"text" = The content itself you want to send
		"separator" = A string that will define when a 'word' starts or ends
*/}}
{{define "sendLongMessage"}}
	{{$outStr:= ""}}

	{{/*If separator is not found on the text, fallback to a default empty string*/}}
	{{if not (in .text .separator)}}
		{{.Set "separator" ""}}
	{{end}}

	{{/*Split text in 'words' and iterate over them*/}}
	{{range (split .text .separator)}}
		{{/*Keep appending words while length is under the limit. Then, send the message and "reset" the content for a new message*/}}
		{{- if gt (add (len $outStr) (len .)) 2000}}
			{{- sendMessage $.channelID $outStr}}
			{{- $outStr = .}}
		{{- else}}
			{{- $outStr = joinStr $.separator $outStr .}}
		{{- end -}}
	{{end}}

	{{/*Send the last message, that was left when range loop ended*/}}
	{{sendMessage .channelID $outStr}}
{{end}}


{{/*If CC was called via execCC/scheduleUniqueCC, use .ExecData as the $args. If not, use .CmdArgs*/}}
{{$args:= cslice}}
{{with .ExecData}}
	{{$args = .}}
{{else}}
	{{/*Delete duplicated $args*/}}
	{{range .CmdArgs}}
		{{- if not (in $args .)}}
			{{- $args = $args.Append .}}
		{{- end}}
	{{- end}}
{{end}}
{{$numArgs:= len $args}}

{{/*Exec can be called 5 times max, so $selectedArgs will have up to 5 $args to be processed*/}}
{{$selectedArgs:= cslice}}
{{if gt $numArgs 5}}
	{{$selectedArgs = slice $args 0 5}}

	{{if $limitTo5CCs}}
		{{sendMessage nil "‚ö†Ô∏è WARNING: Only first 5 CCs will be processed"}}
	{{end}}
{{else}}
	{{$selectedArgs = $args}}
{{end}}

{{/*Convert each $blacklisted_CCIDs to a RegEx pattern*/}}
{{range $index, $CCID:= $blacklisted_CCIDs}}
	{{- $blacklisted_CCIDs.Set $index (printf "^#%d.*" $CCID)}}
{{end}}

{{/*Process each selected argument in this execution*/}}
{{range $selectedArgs}}
	{{/*EXECute "-cc" and extract stuff from its output*/}}
	{{- $answer:= exec "cc" .}}
	{{- $answerLines:= split $answer "\n"}}
	{{- $extractedCode:= slice $answerLines 2 (sub (len $answerLines) 1)}}
	{{- $firstLine:= index $answerLines 0}}
	{{- $blacklisted:= false}}

	{{/*Check if that CC was $blacklisted*/}}
	{{range $blacklisted_CCIDs}}
		{{- if reFind . $firstLine}}
			{{$blacklisted = true}}
		{{- end}}
	{{end}}

	{{/*Check if Answer's $firstLine is actually an error message*/}}
	{{- if in $firstLine "here is a list of"}}
		{{- sendMessage nil (printf "‚ùå CC `%s` not found" .)}}
	{{- else if in $firstLine "More than 1 matched command"}}
		{{/*Insert argument in message output, and if it's empty, replace it with "<Empty trigger specified>"*/}}
		{{- $msj:= reReplace "``" (printf "`%s`: %s" . $answer) "`<Empty trigger specified>`"}}
		{{- template "sendLongMessage" (sdict "channelID" nil "text" $msj "separator" "\n")}}
	{{- else if $blacklisted}}
		{{- sendMessage nil (printf "üö´ CC `%s` is blacklisted" .)}}
	{{- else}}
		{{/*No error message, so send CC's code and info*/}}
		{{- $content:= ""}}
		{{- $attachment:= joinStr "\n" $extractedCode}}

		{{/*If $CCInfo_MessageContent flag is set, the info will be sent as message content*/}}
		{{- if $CCInfo_MessageContent}}
			{{- $content = $firstLine}}
		{{- end}}

		{{/*If $CCInfo_Attachment flag is set, the info will be a comment in message's attachment*/}}
		{{- if $CCInfo_Attachment}}
			{{- $attachment = printf "{{/* CC INFO: %s */}}\n\n%s" $firstLine $attachment}}
		{{- end}}

		{{- sendMessage nil (complexMessage
			"content" $content
			"file" $attachment
		)}}
	{{- end}}

	{{- sleep 1}}
{{else}}
	{{/*If there are 0 args, send full CC list*/}}
	{{template "sendLongMessage" (sdict "channelID" nil "text" (exec "cc") "separator" "\n")}}
{{end}}

{{/*If $limitTo5CCs flag is not set, and there are still arguments left, execute CC again to process them*/}}
{{if and (not $limitTo5CCs) (gt $numArgs 5)}}
	{{scheduleUniqueCC .CCID nil 1 "cc2file - remaining args" (slice $args 5 $numArgs)}}
{{end}}
